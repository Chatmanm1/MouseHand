import cv2
import mediapipe as mp
import tkinter as tk
from tkinter import filedialog
import math

# Initialize MediaPipe Pose model
mp_pose = mp.solutions.pose
pose = mp_pose.Pose()

# Create a GUI window to select the video file
root = tk.Tk()
root.withdraw()  # Hide the root window

# Prompt user to select a video file using a file dialog
file_path = filedialog.askopenfilename(title="Select Video File", filetypes=[("Video Files", "*.mp4;*.avi;*.mkv")])

# Check if a file was selected
if file_path:
    # Open the selected video file
    video_capture = cv2.VideoCapture(file_path)

    # Get video properties (frame width, height, and frame rate)
    frame_width = int(video_capture.get(cv2.CAP_PROP_FRAME_WIDTH))
    frame_height = int(video_capture.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = int(video_capture.get(cv2.CAP_PROP_FPS))

    # Define codec and create VideoWriter object
    fourcc = cv2.VideoWriter_fourcc(*'XVID')
    output_file = 'output_with_landmarks.avi'  # Output video file name
    out = cv2.VideoWriter(output_file, fourcc, fps, (frame_width, frame_height))

    while video_capture.isOpened():
        ret, frame = video_capture.read()
        if not ret:
            break

        # Convert the image to RGB and process with MediaPipe Pose
        image_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
        results = pose.process(image_rgb)

        # Draw pose landmarks on the frame
        if results.pose_landmarks:
            mp.solutions.drawing_utils.draw_landmarks(frame, results.pose_landmarks, mp_pose.POSE_CONNECTIONS)

            # Check if landmarks are present before accessing them
            if results.pose_landmarks.landmark:
                # Calculate the angle between landmarks 25, 26, and the average of landmarks 23 and 24
                landmark_23 = results.pose_landmarks.landmark[23]
                landmark_24 = results.pose_landmarks.landmark[24]
                landmark_25 = results.pose_landmarks.landmark[25]
                landmark_26 = results.pose_landmarks.landmark[26]

                # Calculate the average of landmarks 23 and 24
                avg_landmark_x = (landmark_23.x + landmark_24.x) / 2
                avg_landmark_y = (landmark_23.y + landmark_24.y) / 2
                avg_landmark_z = (landmark_23.z + landmark_24.z) / 2

                # Calculate vectors for the three points
                vec1_x = landmark_25.x - avg_landmark_x
                vec1_y = landmark_25.y - avg_landmark_y
                vec2_x = landmark_26.x - avg_landmark_x
                vec2_y = landmark_26.y - avg_landmark_y

                # Calculate dot product and magnitudes of vectors
                dot_product = vec1_x * vec2_x + vec1_y * vec2_y
                magnitude_vec1 = ((vec1_x ** 2) + (vec1_y ** 2)) ** 0.5
                magnitude_vec2 = ((vec2_x ** 2) + (vec2_y ** 2)) ** 0.5

                # Calculate the cosine of the angle
                cosine_angle = dot_product / (magnitude_vec1 * magnitude_vec2)

                # Calculate the angle in radians
                angle_rad = math.acos(cosine_angle)

                # Convert radians to degrees
                angle_deg = math.degrees(angle_rad)

                # Display the angle on the frame
                cv2.putText(frame, f"Legs to Hip Angle: {angle_deg:.2f} degrees", (50, 50), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 0, 0), 2)

        # Write the frame with pose landmarks to the output video file
        out.write(frame)

        # Display the frame with pose landmarks and angle measurement
        cv2.imshow('Pose Detection', frame)
        if cv2.waitKey(1) & 0xFF == ord('q'):
            break

    # Release the video capture, VideoWriter, and close the window
    video_capture.release()
    out.release()
    cv2.destroyAllWindows()
    print(f"Video with landmarks overlay saved as '{output_file}'")
else:
    print("No video file selected.")
